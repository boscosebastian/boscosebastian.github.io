# Analysis of CVE-2018-16513 Vunerability in Ghostscript

# Introduction

**Ghostscript** is an interpreter for Adobe System&#39;s **PostScript** and for Portable Document Format (**PDF)** page description language. It consists of a PostScript interpreter layer, and a graphics library. It is used in rasterization and rendering of such page description language files for displaying and printing and used as a format converter, such as Postscript to PDF converter.

There were a couple of vulnerabilities published by Tavis Ormandi[CITATION Tav \l 1033] in **Ghostscript**.

This blog is going to discuss &quot; **setcolor**&quot; vulnerability in Ghostscript.

# Analysis

Ghostscript crashes when setpattern is called in the postscript with a dictionary as shown in Figure 1.

 ![1.png](/attachments/15_1_1.png)

Figure 1: Crash

The call stack after the crash looks like (in Figure 2):

 ![1.png](/attachments/15_1_2.png)

Figure 2: Call Stack

It is crashing in function array\_get().

It is trying to get some content from some memory. The assembly instruction at which the program crashes is following:

 ![1.png](/attachments/15_1_3.png)

Figure 3: Assembly Code and Register Values

The value which register rsi contains is zero, and it is trying to access memory location rsi + 0x4(0x04). This leads to Segmentation fault.

By back tracing **array\_get()** function, it is found that **array\_get()** is called by **zsetcolor()** function.

 ![1.png](/attachments/15_1_4.png)

Figure 4: zsetcolor() Function

The zsetcolor() function calls array\_get() function at line number 288 in figure 4.  In the array\_get() function (in figure 5), it tries to get the size of the structure pointed by the second parameter (aref) of the function.

 ![1.png](/attachments/15_1_5.png)
Figure 5: array\_get() Function

The size of this structure is stored at +4 location of the structure. In this case, the aref is pointing to NULL.

In linux calling convention uses register rsi holds second parameter to a function. From figure 3, it can be seen that the register holds 0, while in array\_get() function.

From figure 4, zsetcolor function calls array\_get() function with pImpl as second parameter. By back tracing we find that this variable is returned by another function **dict\_find\_string()**.

**dict\_find\_string()** function is defined as shown in figure 6:

 ![1.png](/attachments/15_1_6.png)

Figure 6: dict\_find\_string() Function

Line no.  286 (Figure 4) calls the dict\_find\_string() function in zsetcolor(). It looks for the key &#39;Implementation&#39; in the op dictionary. &#39;Implemenation&#39; key contains an ID, which is assigned to it after executing the form. However, the dictionary (_\&lt;\&lt;/whatever 414141\&gt;\&gt;_) in the input is created by the user and does not contain this key.

But the function **dict\_find\_string()** is returning an error code because it could not find the key &#39;Implemenation&#39; in the dictionary. Upon further analysis the function **dict\_find\_string()** is again calling another function **dict\_find()** function. This function is returning with error:

 ![1.png](/attachments/15_1_6_0.png)

Figure : Error Code Returned from dict\_find()This error in turn is captured by **dict\_find\_string()** function and returns with error:

 ![1.png](/attachments/15_1_7.png)

Figure 7: Error Code Returned from dict\_find\_string()

Since the function could not find &#39;Implemenation&#39; key, pImpl is not updated with address but contains zero.

During the function call to dict\_find\_string(), the parameters as shown in figure 8 (gdb output).

 ![1.png](/attachments/15_1_8.png)

Figure 8: Parameter values to dict\_find\_string()

rdx register holds the pointer to pImpl, which contains 0 as shown above.

After the call return from the dict\_find\_string() the return value in rax is 0xffffffeb (-21 in decimal) and the value at 0x7fffffffcfb8 (pImpl) is still zero as shown in the gdb out put in figure 9.

 ![1.png](/attachments/15_1_9.png)

Figure 9: Value of rax and pImpl after exiting from dict\_find\_string()

Next line in the function **zsetcolor** is checking if the value returned in &#39;code&#39; is not equal to zero, if then pass the address returned by **dict\_find\_string()** to **array\_get()** function.

 ![1.png](/attachments/15_1_10.png)

Actually the check should have been if code \&gt; 0 instead of code != 0.

The **array\_get()** tries to get info from the address returned in **pImpl** , which in this case is 0 from the **dict\_find\_string()** which results in segmentation fault, crashing the application.

Artifex patched the code by putting necessary checks.

 ![1.png](/attachments/15_1_11.png)

# Conclusion

Successful exploitation of this vulnerability leads to DoS, by crashing the Ghostscript application. It can possibly have other unspecified impacts.
